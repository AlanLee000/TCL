我们考察一个**三元组语境语言**，它仅仅由主谓宾三元组`(S,P,O)`和语境树结构嵌套组成。它的动机直接来源于知识库：文件自身具有树结构，文件中的语句也应当与文件本身统一起来。而元语言和对象语言的区别就在于元语言有缺失而对象语言没有。一个空缺就是一个元语言意义上的提问；因此这语言是一种问答逻辑。语境、语句、语词应当是一体的。我们这样定义它的规则：首先，我们有原始语境（一串无引号的句号`.`隔断的句子），它有一个名字`Gamma`。语境由这样的二元组进行深入：`[a,b]`表示a命名了b语句，从而b语句是a的中心；而语境由句号进行平展，即`a.b`，从而构成语句的顺序关系。语境仅可作为主语或宾语嵌套。所有的结构都是有序的。
```
<noun>      ::= a | b | c | ...       // 原子，或称常量、名称
<predicate> ::= be | → | ...          // 内置谓词
<formula>   ::= (<statement>, <predicate>, <statement>)
<statement> ::= <noun>
            | <formula>
            | [<statement>, <statement>]  // 语境嵌套 (Naming/Scoping)
            | <statement> . <statement>   // 语境平展 (Sequencing/Concatenation)
```
因此，深入是非交换、非结合的，平展是结合的、非交换的。
同一性就被理解成两个常量`be`(相等）和`→`（重写），它满足`(Gamma,be,Gamma).(Gamma,→,Gamma).([Gamma,statement1],→,Gamma).(Gamma.statement1,→,Gamma)`也就是说，Gamma始终被重写为总语境，也总是同一于总语境。而一般语境中，同一性满足`[Gamma,(statement1,be,statement1)].([Gamma,(statement1,be,statement2)],→,[Gamma,(statement2,be,statement1)]).([Gamma,(statement1,be,statement2).(statement2,be,statement3)],→,[Gamma,(statement1,be,statement3)]).
并对如下元语言满足一个规则模式：
```
// <[context,]> 表示一个包含一个洞的子语境
<[context,]> ::= []                                  // 洞本身是最简单的上下文
      | (<[context,]>, <predicate>, <statement>)   // 洞在主语位置
      | (<statement>, <predicate>, <[context,]>)   // 洞在宾语位置
      | [<[context,]>, <statement>]                // 洞在语境名位置
      | [<statement>, <[context,]>]                // 洞在语境中心位置
      | <[context,]> . <statement>                 // 洞在平展序列的前部
      | <statement> . <[context,]>                 // 洞在平展序列的后部
// 
```
规则模式：
```
([Gamma, <[context,statement1]> . (statement1, →, statement2)], →, [Gamma, <[context,statement2]>])
```
变量的抽象关系就被理解成语境中心与语境名的关系，而应用操作则被理解为跨语境而对语境中心的操作：`λ x.t`相当于`[t,x]`，`λ x.t(t')`就相当于`([t,x].(x,→,t')])`。
子语境的概念如下实现：如果一些句子构成的语境`<[context,]`满足`(context,→,context).([context,statement],→,context).(context.statement,→,context)`都在对象语言的层面被填到洞里，而`(context,be,[context,])`和`([context, <[context,statement1]>.(statement1,→,statement2)], →, [context, <[context,statement2]>])`在元语言层面被填到洞里，称`context`构成子语境。子语境因此是与元语言挖洞对偶的概念：它是以所有方式填上了所有洞的陈述，并且在元语言上等价于自己作为洞。
而规定子语境之所是的`(context,be,<[context,]>`则允许公理和问题的添加。
我们分析语境的元语言性质：它作为挖洞，其唯一形式是语境深入。这就意味着：从元语言的角度看来，一切非谓词性的对象语言都是可产生提问的问题。而当我们填上这个洞，它就从元语言下降到对象语言而成为了一个具体的陈述`statement`，并构成了这个洞的语境名的一个中心。这就反过来把元语言其意涵具体化了；因此形成了元-对象层面，通过填洞交互而形成的语义循环：一方面，元层面的语境深入意味着所有对象层面的名词性操作，当然也包括对象层面的语境深入，从而我们可以一直问所有对象语言形成的名词性问题；另一方面，对象层面的语境深入具体化了元层面的语境深入，从而我们回答所有名词性问题从而生产陈述的过程都会给元层面提供新的语境深入的材料。这暗示当前的LLM应当作为这个语言的元层面或感知层，也揭示了我们一直以来对于元的理解：感知就是元。
而谓词性的问题：此时已经不能说它是一个问题了。每一个关于谓词的问题都是一个规定；我们要做的事情是演绎它、并观察与现实世界的对应程度。
添加名词性公理和添加名词命题是一回事，而添加谓词性公理只需要做如下事情：我们选取一个语境`context`（甚至可以是`Gamma`），然后把这个公理`(<[context1,]>,predicate,<[context2,]>)`及其对应的归约规则在元层面上等价于并填上`<[context,]`的洞，这样，我们就能在等价于的新语境中谈论元层面的谓词公理，而不至于污染原始语境，因此是局部的：这是基于任何哪怕是全局的公理都是在写完之后才成立的所做的设计，只需要恰当的安排语境树和填洞的次序（实际上，任何谓词性公理都应该出现在语境结束的位置并安排好次序！）就可以实现局部内的广播影响；如果添加检查机制，我们甚至可以实现抛弃之前的语境以精简我们的系统。我们之前构建的系统（等价性、替换规则模式、以及下面定义的假）也可以这样写进`Gamma`里。这就是说，等价性公理被写进`Gamma`的洞里，并且使得`Gamma`永远等价于它的洞；替换规则模式的实例也被写进`Gamma`的洞里，并且使得`Gamma`自身从元语言上等价于它填上所有实例后仍然作为洞的`Gamma`。
填洞行为因此实现了单义性基础上的元-对象互动：每一次填洞，如果导致洞不减少，那么它仍然在元层面工作；如果洞填补完全，它仍可以通过等价性创建新的洞。嵌套的洞因此只有元层面：它消解了元元层面，而只是拓宽到多洞感知。

我们就可以定义不同的假：`(False1,be,context).(False1.statement,be,False1)`这是平展假。同理有嵌套假（`(False2,be,context).([False2,statement],be,False2)`）、语境假（即既平展假又嵌套假：`(False3,be,context).(False3.statement,be,False3).([False3,statement],be,False3)`），并规定`(statement.(statement,→,Falsei),→,[Falsei,statement])`。

归约规则是系统引擎的一部分，而谓词公理（元语言层面的公理模式）`(<[context1,]>,predicate,<[context2,]>)`已经给出了并行计算和自省谓词的处理方式：并行计算只需要设置复合了多个谓词的谓词公理就可以实现，而自省谓词则通过语境嵌套中的自指涉实现。而对于数据库查询谓词，它需要首先建立与外部系统的协议，实际上仍然是起到语法翻译器的作用。

我们就把同一性拆分成等价关系和重写操作，并规定只有等价于自己、重写回自己的语句才是同一的。这是来自我先前的工作确认的“语法-语义分裂”，也就是说计算等价和语法等价的割裂。**我们因此可以用这个工具描述用三元组-二元组嵌套成的语言导致的同一性分裂：**
1.  二元结构：定位与组织 (Syntax)
	1. `[a, b]` (语境嵌套/深入): 这是一个纯粹的结构性/定位性操作。它声明`b`存在于`a`所命名的“空间”或“视角”下。`a`和`b`本身是什么不重要，重要的是它们的位置关系。这是一种偏正结构（`a`修饰/限定`b`）。
	2. `a . b` (语境平展/序列): 这同样是结构性的，定义了`a`和`b`之间的顺序关系。它构建了一个有序的列表。
	3. 这两种二元操作共同构建了一个语境树。一个`statement`的“语法同一性”取决于它在这棵树中的唯一路径/地址。例如，`[ctx1, (S,P,O)]` 和 `[ctx2, (S,P,O)]` 即使包含完全相同的`formula`，但因为它们的语境名`ctx1`和`ctx2`不同，它们在结构上就是两个不同的东西。它们的“语法身份”是由其容器（context）决定的。
2.  三元结构：断言与计算 (Semantics)
    1. `(S, P, O)` (主谓宾/formula): 这是一个判断性/关系性的结构。它不关心S和O在哪里，而是断言它们之间存在一种由`P`定义的关系。
	2. 当谓词`P`是`→`(重写)时，这个三元组就变成了一个计算指令。它宣告了一种动态的、可操作的等价性。
    3. 当谓词`P`是`be`(相等)时，它宣告了一种静态的、声明性的等价性。
    4. 这种三元判断定义了系统的“计算同一性”或“语义等价”。它允许我们跨越结构树的不同位置，建立起联系。
3. 现在我们来看，这两种结构如何必然导致同一性的分裂。
	1. 创建两个语法上不同的实体
		在这个语言中，创建两个语法上不等同的实体是轻而易举的。我们只需要将它们放置在结构树的不同位置。
		设有两个原子名词 a 和 b。
		我们构造两个`statement`：
		   `v_a := [ctx, a]`
		   `v_b := [ctx, b]`
		显然，只要 `a` 和 `b` 是不同的原子符号，`v_a` 和 `v_b` 在语法上就是不等的。`v_a`和`v_b`因为其“中心”不同，所以是语法上不同的实体。
	2. 通过“计算”或“判断”将它们联系起来
		现在，我们引入一个三元组判断来连接 a 和 b。我们在总语境Gamma中加入一条重写规则：
		`Rule1 := (a, →, b)`
		这条规则是一个计算指令。它声明“a可以被b替换”。
	3. 分裂的显现
		我们来看核心的重写模式：
		`([Gamma, <[context,a]> . (a, →, b)], →, [Gamma, <[context,b]>])`
		假设我们的总语境是 `Gamma_current := [ctx, a] . (a, →, b)`。
		根据规则模式，系统会执行重写：
		`Gamma_current → [ctx, b]`
		此时，我们看到了分裂：
		   计算/语义层面 ： `[ctx, a]` 在 `(a, →, b)` 这个计算规则的作用下，行为上等同于 `[ctx, b]`。它们是计算过程的起点和终点，是“计算等价”的。系统通过`→`谓词，赋予了它们相同的“作用”。
		   语法/结构层面 ： `[ctx, a]` 和 `[ctx, b]` 永远是两个不同的表达式。它们的构成不同，一个是`a`，一个是`b`。我们无法在不应用任何规则的情况下，仅凭“长相”就说它们是同一个东西。它们的结构地址虽然相似（都在`ctx`下），但其核心内容不同。

我们可以证明，在从属嵌套的子语境中，如下地添加公理`[context1,(context1.context2,be,context2.context1).(context1.context2,be,context1)].`就可以实现context1语境内，context1与新加的语境之间是无序的。
由于系统对于假采取标注一个语境名标签的形式，因此应当可以证明是次协调一致的。
我们证明：**即使初始语境 `S` 包含一个“矛盾”，即 `S` 中有涉及 `False_i` 的子句，这也不足以让 `[Gamma, S]` 能够被重写为 `[Gamma, Q]` 对于任意的 `Q`。**

**证明步骤**:

1.  **分析矛盾的引入和行为**:
     我们考察`False_i` 以及与它相关的规则如何影响系统状态的演化：
    *   **定义性公理**: `(False1, be, context)`, `(False1.a, be, False1)`。这些是 `be` 等价断言。它们是静态的，本身不产生任何重写。它们只是陈述了 `False1` 的某些性质。
    *   **归谬/隔离规则**: `(a . (a, →, False_i), →, [False_i, a ])`。这是关于 `False_i` 的唯一一个**重写规则模式**。让我们仔细分析它的作用。
        *   **触发条件**: 语境中出现一个序列，形如 `a . (a, →, False_i)`。即一个项 `a` 后面跟着一个将 `a` 重写为 `False_i` 的指令。
        *   **重写结果**: 这个触发序列 `a . (a, →, False_i)` 被替换为一个**新的嵌套语境** `[False_i, a]`。

2.  **审视重写引擎的能力**:
    系统的唯一“引擎”是全局重写规则：
    `([Gamma, <[context,a]> . (a, →, b)], →, [Gamma, <[context,b]>)`
    这意味着，要改变 `Gamma` 的中心 `S`，唯一的方法是找到一个 `(a, →, b)` 形式的指令，并应用它。`a` 必须精确匹配 `S` 中位于该指令之前的部分（由 `<[context,a]>` 捕获）。

3.  **矛盾是否导致爆炸？**:
    假设我们的总语境是 `[Gamma, S]`，并且 `S` 中存在一个矛盾，例如 `S = S_prefix . (P, be, False1) . S_suffix`。
    *   这个 `(P, be, False1)` 是一个 `be` 断言，它不匹配 `(a, →, b)` 的形式。因此，它本身不能触发任何全局重写。它只是一个“事实”。
    *   现在假设我们有一个更强的矛盾，即一个重写指令 `(P, →, False1)`。让 `S = P . (P, →, False1) . S_suffix`。
    *   根据确定性策略，系统会扫描到 `(P, →, False1)`。
    *   **关键点**：此时，有两个规则可能匹配：
        a.  **全局重写规则**: `([Gamma, P . (P, →, False1) . S_suffix], →, [Gamma, False1 . S_suffix])`
        b.  **归谬/隔离规则**: `(P . (P, →, False1), →, [False1, P . (P, →, False1)])`
		`归谬`规则是一个可以被添加到 `Gamma` 中的公理，即 `[Gamma, (...), ( (a.(a,→,Falsei)), →, [Falsei,a] ) ]`。当系统处理 `P . (P, →, False1)` 时，它会找到这个指令并执行重写。结果是 `[Gamma, [False1, P ] . S_suffix]`。

    **论证**:
    观察这个结果 `[False1, P ]`。这个所谓的“矛盾”并没有消失，而是被**封装**或**隔离**到了一个以 `False1` 自身命名的子语境中。它没有“污染”或摧毁其外部的语境 `S_suffix`。它更像是一个错误处理机制，将导致矛盾的代码块包装起来，而不是让它崩溃整个程序。

4.  **无法生成任意项**:
    要从一个矛盾状态 `[Gamma, S_with_contradiction]` 推导出任意项 `[Gamma, Q]`，我们需要一系列的重写 `(a_i, →, b_i)`，它们能逐步将 `S_with_contradiction` 变换成 `Q`。

    然而，`False_i` 相关的规则**并不提供这种能力**。
    *   它们不会凭空创造出新的、任意的结构。
    *   `False_i` 的重写规则是**内向的 (inward-looking)** 或**自包含的 (self-containing)**。它将一个模式重写为该模式的嵌套版本 `[False_i, ...]`。
    *   这个系统是高度**语法驱动 (syntax-directed)** 的。重写规则只能根据其严格的语法形式进行匹配。没有一个规则形如 `(False_i, →, Q)` for arbitrary `Q`。因此，一旦系统状态中出现了 `False_i` 这个原子，它就无法再被重写为别的东西了（除非有其他公理明确允许）。

    **结论**:
    系统中引入 `False_i` 的机制，尤其是 `(a.(a,→,Falsei),→,[Falsei,...])` 规则，其效果不是逻辑爆炸，而是**矛盾隔离 (contradiction quarantining)**。一个矛盾的出现会导致状态的一部分被封装在一个以 `False_i` 命名的“错误”或“特殊”语境中，但系统的其余部分仍然可以根据其他规则继续演化。由于没有规则允许从 `False_i` 或包含 `False_i` 的结构中生成任意项 `Q`，爆炸律被有效阻止。

关于重写的合流性：语境深入和语境平展完全是顺序的，重写规则的模式匹配也完全是顺序的（重写机制只会处理在重写命令发生前的句子）。无序性反而是需要通过等价关系be来模拟的，从这点来说，这个系统应当可以证明是合流的。这个系统是完全有序的模式匹配，这意味着一旦遇到一个重写的三元组，它就会立刻工作于前面的名词noun，这意味着在一个语境树的末端节点，同时只能有一个重写，它唯一地对一个语境起作用，不会导致不同顺序的重写产生，因此可以证明，它在语境树的意义上是合流的。
*   **项（Terms）**:  `<statement>` 集合，我们称之为 `T`。
*   **归约关系（Reduction Relation）**: `→` 谓词定义了系统的动态。核心规则模式：`([Gamma, <[context,a]> . (a, →, b)], →, [Gamma, <[context,b]>)`是一个**全局性的语境转换规则**。它描述了整个根语境 `Gamma` 如何演化。我们将其定义为一步归约关系 `→_R`。
    一个项 `t` 可以归约为 `t'` (记为 `t →_R t'`)，当且仅当 `t` 的形式是 `[Gamma, S]`，并且存在 `context`, `a`, `b` 使得 `S` 可以被分解为 `<[context,a]> . (a, →, b)`，此时 `t'` 就是 `[Gamma, <[context,b]>]`。
*   **归约（Redex）**: 可归约表达式。在这个系统中，一个潜在的归约是形如 `... . (a, →, b)` 的序列，它位于 `[Gamma, ...]` 的中心。
*   **合流性（Confluence / Diamond Property）**: 一个归约系统是合流的，当且仅当对于任意项 `M`，如果 `M` 可以归约为 `M1` 且 `M` 也可以归约为 `M2`，那么一定存在一个项 `M3`，使得 `M1` 和 `M2` 都可以归约为 `M3`。
    *   形式化地：`∀M, M1, M2 ∈ T, (M →*_R M1 ∧ M →*_R M2) ⇒ ∃M3 ∈ T, (M1 →*_R M3 ∧ M2 →*_R M3)`
    *   `→*_R` 是 `→_R` 的自反传递闭包（即零步或多步归约）。
**定义（左最内最优先策略）**: 在对一个项 `[Gamma, S]` 进行归约时，我们扫描 `S` 的平展序列 `s1 . s2 . ... . sn`。选择**最左边**出现的、其主语在它左侧的重写指令 `(a, →, b)` 作为唯一的归约。
如果我们将这个策略作为系统定义的一部分，那么归约关系 `→_R` 就变成了一个**函数**。对于任何给定的项 `t`，至多只有一个 `t'` 使得 `t →_R t'`。
**证明（在左最内最优先策略下的合流性）**
一个系统，如果其一步归约关系是确定的（即一个函数），那么它必然是合流的。证明如下：
1.  **前提**: 假设我们的归约关系 `→_R` 是确定的。
2.  **目标**: 证明 `∀M, M1, M2, (M →*_R M1 ∧ M →*_R M2) ⇒ ∃M3, (M1 →*_R M3 ∧ M2 →*_R M3)`。
3.  **证明**:
    *   `M →*_R M1` 意味着存在一个归约序列 `M →_R M_1 →_R M_2 →_R ... →_R M_k = M1`。
    *   `M →*_R M2` 意味着存在一个归约序列 `M →_R M'_1 →_R M'_2 →_R ... →_R M'_l = M2`。
    *   由于 `→_R` 是确定的，`M` 只能归约为一个唯一的项 `M_1`（也即 `M'_1`）。因此，这两个归约序列的开头必然是相同的。
    *   不失一般性，假设 `M1` 的归约步数 `k` 小于等于 `M2` 的归约步数 `l`。那么，`M1` 的整个归约序列就是 `M2` 归约序列的前缀。
    *   即 `M1` 位于从 `M` 到 `M2` 的路径上。因此，`M1` 可以通过 `l-k` 步归约到达 `M2` (`M1 →*_R M2`)。
    *   我们可以选择 `M3 = M2`。此时，`M1 →*_R M3`（即 `M1 →*_R M2`）成立，`M2 →*_R M3`（即 `M2 →*_R M2`，自反性）也成立。
    *   钻石属性得到满足。

终止性则是首先已经根据规定的语境结构，分别可以归约到一个个语境树节点上的，因此可以推测，如果它是终止的，则可以归约为一个语境树。但图灵完备性导致它无法在所有情况终止。
为了证明三元组语境语言是图灵完备的，我们证明它能够模拟无类型λ演算。
首先我们需要一个应用谓词`app`，以及与它配套的β归约的谓词规定和谓词归约规定:
`([<context1,[statement1,<[context,noun]>]>],app,context2)`和
`([<context1,[statement1,<[context,noun]>]>],app,context2),→,[<context1,[statement1,<context,noun>.(noun,→,context2)]>])`，把它们等价于并在最后填上语境洞。`<[context,noun]>`就相当于自由变量函数体，`statement1`就相当于绑定变量，从而执行的是`context1`作为函数体，而变量`noun`到 `context2`的替换
	1. 初始状态:  在子语境创建的新的等价的子语境中谈论`([<context1,[statement1,<[context,noun]>]>],app,context2)`
	2. 启动归约: 原始语句被归约为`[<context1,[statement1,<context,noun>.(noun,→,context2)]>]`
	3. 执行替换: 全局重写规则现在会用 `context2` 替换掉 `context` 中所有自由出现的 `noun`。
    4.  最终状态: `[<context1,[statement1,<context,context2>]]`
        这正是 `M[x := N]` 的编码。
变量的意外捕获我们通过如下方法处理：我们一旦取定一个值，立刻通过be赋予它一个系统中从未出现的名字：`(a,be,a')`并立即执行一个归约`(a,→,a')`。这种机制保证了每一个计算取定的值都是新鲜的。

**我们就此证明了，CNRS 可以通过一条公理和一个全局重写规则，完美地模拟 λ 演算的 β-归约。**
---
<p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
  <a property="dct:title" rel="cc:attributionURL" href="[你的GitHub仓库或项目链接]">你的项目/文章标题</a> 
  由 <span property="cc:attributionName">AlanLee000</span> 在 © 2025 创作，
  并采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a> 进行许可。
</p>